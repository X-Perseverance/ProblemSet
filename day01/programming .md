### 1. 标题：[组队竞赛](https://www.nowcoder.com/questionTerminal/6736cc3ffd1444a4a0057dee89be789b?orderByHotValue=1&page=1&onlyReference=false)

- **【题目解析】**<br>

&#160; &#160; &#160; &#160; 通过题目我们可知，每一个队伍的水平值等于该队伍的次大值，为了使所有队伍的水平值总和最大，就需要让每个队伍的次大值尽可能大。<br>

- **【解题思路】**<br>

&#160; &#160; &#160; &#160; 本题的主要思路是`贪心算法`，贪心算法其实很简单，就是每次选值时都选当前能看到的局部最优解，所以这里的贪心就是保证每组的次大值是当前可选数据范围中的次大值。具体方法如下：<br>
&#160; &#160; &#160; &#160; （1）对所有数据进行升序排序；<br>
&#160; &#160; &#160; &#160; （2）共有 3n 个数据，下标从 0 到 3n-1。当第一次取值时，数据范围为 [0 ~ 3n-1]，那么下标为 3n-2 的数据为次大值；第二次取值时，数据范围为 [0 ~ 3n-3]，那么下标为 3n-4 的数据为次大值。以此类推，所以最后，我们将下标为 3n-2，3n-4，3n-6 ... n+2，n 的数据累加起来作为最后的结果。<br>

- **【示例】**<br>

&#160; &#160; &#160; &#160; 假如，现有一组数据为 1 5 8 5 9 2，对其排序后为 1 2 5 5 8 9，接着按照上述方法依次取值，如下：

|  | 当前可选数据范围 | 次大值 |
| :--: | :--: | :--: |
| 第一次取值 | 1 2 5 5 8 9 | 8 |
| 第二次取值 | 1 2 5 5 | 5 |

&#160; &#160; &#160; &#160; 可见，最后的结果就是 8 和 5 之和，即 15。

- **【代码】**<br>
```c++
#include <iostream>
#include <vector>
#include <algorithm>
 
using namespace std;
 
int main() {
    int n = 0;
     
    while(cin >> n) {
        vector<int> v;
        v.resize(3*n);
         
        for(int i=0; i<3*n; ++i)
            cin >> v[i];
         
        sort(v.begin(), v.end()); //升序排序
         
        long long maxSum = 0;
        for(int i=n; i<=3*n-2; i=i+2) //依次取次大值
            maxSum += v[i];
         
        cout << maxSum << endl;
    }
     
    return 0;
}
```

### 2. 标题：[删除公共字符](https://www.nowcoder.com/practice/f0db4c36573d459cae44ac90b90c6212?tpId=85&&tqId=29868&rp=1&ru=/activity/oj&qru=/ta/2017test/question-ranking)

- **【解题思路】**<br>

- [ ] 传统方法：<br>

> &#160; &#160; &#160; &#160; （1）判断第一个字符串中的每一个字符是否在第二个字符串中；<br>
> &#160; &#160; &#160; &#160; （2）若存在，则挪动后面的字符依次覆盖前一个字符；若不存在，则判断下一个字符。<br>
> &#160; &#160; &#160; &#160; 这种方法的时间复杂度为 `O(N^2)`，效率太低，很难让人满意。<br>

- [x] 高级方法：<br>

> &#160; &#160; &#160; &#160; （1）将第二个字符串中的字符都映射到一个 hashtable数组 中，以便用来判断第一个字符串中的字符是否在第二个字符串中；<br>
> &#160; &#160; &#160; &#160; （2）定义一个新字符串，作为最后的结果；<br>
> &#160; &#160; &#160; &#160; （3）依次遍历第一个字符串的字符，若其不在第二个字符串，则将该字符添加到上述新字符串中；若存在，则遍历下一个。<br>
> &#160; &#160; &#160; &#160; 这种方法的时间复杂度为 `O(N)`，相对于上一种方法，其效率大幅提升。因为在这里，我们并不需要完整地去遍历第二个字符串才能判断出一个字符是否存在，而是直接去hashtable数组中查找一次即可。此外，在这种方法中并没有进行数据的挪动，而是将不存在的字符组合成一个新字符串作为结果输出。<br>

- **【代码】**<br>
```c++
#include <iostream>
#include <string>
 
using namespace std;
 
int main() {
    string str1, str2;
    getline(cin, str1);
    getline(cin, str2);
     
    int hashTable[256]={0};
    for(size_t i=0; i<str2.size(); ++i) //将第二个字符串中的字符映射到一个哈希表中
        hashTable[str2[i]]++;
     
    string ret; //定义一个新字符串
    for(size_t i=0; i<str1.size(); ++i) { //遍历第一个字符串
        if(hashTable[str1[i]] == 0) //若在第二个字符串中不存在，则将其重新组合，作为最终的结果
            ret += str1[i];
    }
     
    cout << ret << endl;
     
    return 0;
}
```
