### 1. 标题：[不要二](https://www.nowcoder.com/practice/1183548cd48446b38da501e58d5944eb?tpId=85&&tqId=29840&rp=1&ru=/activity/oj&qru=/ta/2017test/question-ranking)
- **【题目解析】**<br>

&#160; &#160; &#160; &#160; 对于该题，有两个非常关键的地方需要我们注意，一是**任意两块蛋糕的欧几里得距离不能等于2**，在这样一个网格盒子（二维数组）内，由于一个格子只能放一个蛋糕，而与每一个蛋糕相距为2的坐标点只能是在其水平方向和垂直方向，所以这句话的意思就是在每个蛋糕的水平和垂直两个方向相距为2的坐标点不能放蛋糕；另一个是**最多可以放多少块蛋糕**，由于题目要求最多，所以我们就需要考虑一下在什么情况下能放置最多，在多种场合（改变网格盒子的长宽值）下，我们发现按以下方式来放蛋糕是最多的，其中绿色位置为蛋糕：<br>
![images](https://github.com/X-Perseverance/ProblemSet/blob/master/images/CakeMap.png)<br>
&#160; &#160; &#160; &#160; 上面两个地方是解题的关键，也是解题的突破口，只有理解了这两点，才能更好地构造出解题思路。<br>

- **【解题思路一】**<br>

&#160; &#160; &#160; &#160; 先假设所有位置都可以放蛋糕，接着从头遍历整个二维数组，按照上述的放置图例，每统计一个蛋糕就将与该蛋糕水平和垂直两个方向相距为2的位置加以标记，以表示此处不能放蛋糕，遍历完后，即可统计出可放置蛋糕的最多数量。<br>

- **【代码】**
```c++
#include <iostream>
 
using namespace std;
 
int main() {
    int w = 0, h = 0, ret = 0;
    int arr[1000][1000] = {0};
    cin >> w >> h;
     
    for(int i=0; i<h; ++i) {
        for(int j=0; j<w; ++j) {
            if(arr[i][j] == 0) {
                ret++;
                if(i+2 < h) //垂直方向
                    arr[i+2][j] = -1;
                if(j+2 < w) //水平方向
                    arr[i][j+2] = -1;
            }
        }
    }
     
    cout << ret << endl;
     
    return 0;
}
```

- **【解题思路二】**<br>

&#160; &#160; &#160; &#160; 通过找规律发现，整个网格盒子可以放蛋糕的位置都是以上面图例中那4行4列为周期来排布的，所以我们可以从网格盒子的长宽入手，找出它们和这一个周期的蛋糕数的算术关系表达式，那么就能直接求出最终的结果。<br>
&#160; &#160; &#160; &#160; 在每个四行中，第一行和第二行的蛋糕数都是：`line_12 = w / 4 * 2 + ((w % 4 < 2) ? w % 4 : 2)`，第三行和第四行的蛋糕数都是 ：`line_34 = (w - 2) / 4 * 2 + (((w - 2) % 4 < 2) ? (w - 2) % 4 : 2)`。而在这样的网格盒子中，一共有 `h/4` 个完整的四行，所以这些行的蛋糕数为：`h / 4 * (line_12+line_34) * 2`，但对于最后剩余的 `h%4` 行，这些行的蛋糕数就要分情况考虑了：若剩余一行，则蛋糕数为 `line_12`；若剩余两行，则蛋糕数为 `line_12 * 2`；若剩余三行，则蛋糕数为 `line_12 * 2 + line_34`。综上，最后的总蛋糕数就是整四行的蛋糕数加上不足四行的蛋糕数。<br>

- **【代码】**
```c++
#include <iostream>

using namespace std;

int main() {
	int w = 0, h = 0;
	cin >> w >> h;

	int line_12 = w / 4 * 2 + ((w % 4 < 2) ? w % 4 : 2); //第1行或第2行的蛋糕数
	int line_34 = (w - 2) / 4 * 2 + (((w - 2) % 4 < 2) ? (w - 2) % 4 : 2); //第3行或第4行的蛋糕数

	int ret = h / 4 * (line_12 + line_34) * 2; //所有整四行的蛋糕数

	//行数除4有余数的情况：
	if (h % 4 > 0) //至少有第1行
		ret += line_12;
	if (h % 4 > 1) //至少有第1行和第2行
		ret += line_12;
	if (h % 4 > 2) //至少有第1行、第2行和第3行
		ret += line_34;

	cout << ret << endl;

	return 0;
}
```
- **【分析】**<br>

&#160; &#160; &#160; &#160; 对第一种思路而言，它的时间复杂度是`O(wh)`，而第二种思路的时间复杂度为`O(1)`，相对来说更加有效，但是理解起来有些难度，所以我们最好在掌握了第一种方法后，再来理解这种思路。<br>

### 2. 标题：[把字符串转换成整数](https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13、&&tqId=11202&rp=6&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking)
- **【解题思路】**<br>

&#160; &#160; &#160; &#160; 本题的解题思路比较简单，就是从头遍历字符串，每次都将上次的结果乘以10，相当于10进制进位，然后再加上当前位的值，遍历完即可得到最终转换后的结果。<br>

- **【代码】**
```c++
class Solution {
public:
    int StrToInt(string str) {
        size_t size = str.size();
        if(size == 0)
            return 0;
         
        int ret = 0;
        int flag = (str[0] == '-') ? -1 : 1; //判断正负号
        size_t i = (str[0] == '-' || str[0] == '+') ? 1 : 0; //若第一个字符为正负号，则从第二个字符开始遍历；否则，从第一个字符开始遍历
         
        for( ; i<size; ++i) {
            if(!isdigit(str[i]))
                return 0;

            ret = (ret<<1) + (ret<<3) + (str[i]&0xf); //ret = ret*10 + str[i]-'0';
        }
		
        return ret*flag;
    }
};
```

- **【坑】**<br>

&#160; &#160; &#160; &#160; 在该题中，有几个关键的地方一定要记得做特殊处理：<br>
> （1）空字符串<br>
> （2）含有正负号<br>
> （3）含有非数字字符<br>
