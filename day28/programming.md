### 1. 标题：[奇数位上都是奇数或者偶数位上都是偶数](https://www.nowcoder.com/questionTerminal/b89b14a3b5a94e438b518311c5156366)
- **【解题思路】**

　　在偶数位上寻找非偶数，在奇数位上寻找非奇数，找到后将两个数字进行位置互换即可。<br>

- **【代码】**
```c ++
class Solution {
public:
	void oddInOddEvenInEven(vector<int>& arr, int len) {
		int i = 0, j = 1;
		while(i < len && j < len){
			while(i < len && (arr[i] & 1) == 0) //在偶数位上找非偶数
				i += 2;
			while(j < len && (arr[j] & 1) == 1) //在奇数位上找非奇数
				j += 2;
			if(i < len && j < len) //找到后交换两个数
				swap(arr[i], arr[j]);
		}
	}
};
```

### 2. 标题：[猴子分桃](https://www.nowcoder.com/questionTerminal/480d2b484e1f43af8ea8434770811b4a)
- **【解题思路】**

　　从题目中来看，小猴子每次将桃子均分为 5 堆时都会多出来 1 个，所以为了方便计算，我们在最开始时就借给猴子们 4 个桃子，这样的话，每次都可以刚好均分为 5 堆。<br>
  
>　　假设在开始时就有 `X` 个桃子，借给猴子们 `4` 个后，此时就一共有 `X+4` 个桃子。<br>
>　　当第一只小猴子来时，它将 `X+4` 个桃子均分为 5 堆后，拿走 `(X+4)*(1/5)` 个，剩余 `(X+4)*(4/5)` 个桃子。**在这里，有人可能会有疑问：给老猴子的那个桃子去哪里呢？其实，小猴子拿的那一部分就包括了这一个桃子，并且小猴子也没有多得桃子，它实际上得到的桃子数为 `(X+4)*(1/5) - 1 = (X-1)*(1/5)` ，这和在不借给它们 4 个桃子的情况下得到的数量是一样的，不过此时剩余的桃子数相较于之前多了 `(X+4)*(4/5) - (X-1)*(4/5) = 4` 个，但这样就恰巧保证了下一只小猴子分桃时，也能刚好均分为 5 堆。由此可见，所有的小猴子都不会多得桃子，老猴子也不会少得桃子，并且每次小猴子都能刚好将桃子均分为 5 堆，而借给的那 4 个桃子每次都在剩余的那部分里，最后去除即可。**<br>
>　　当第二只小猴子来时，它将 `(X+4)*(4/5)` 个桃子均分为 5 堆后，拿走 `(X+4)*(4/5)*(1/5)` 个，剩余 `(X+4)*(4/5)^2` 个桃子。<br>
>　　当第三只小猴子来时，它将 `(X+4)*(4/5)^2` 个桃子均分为 5 堆后，拿走 `(X+4)*(4/5)^2*(1/5)` 个，剩余 `(X+4)*(4/5)^3` 个桃子。<br>
>　　.....<br>
>　　依次类推，当第 n 只小猴子（最后一只小猴子）来时，它将 `(X+4)*(4/5)^(n-1)` 个桃子均分为 5 堆后，拿走 `(X+4)*(4/5)^(n-1)*(1/5)` 个，剩余 `(X+4)*(4/5)^n` 个桃子。<br>

　　为了满足题目最后的要求，也就是要保证最后剩余的桃子数最少且为整数，那么当 `X+4 = 5^n` 时，刚好满足要求，此时可得出：<br>
（1）**开始时的总桃子数**：`X = 5^n - 4`<br>
（2）**老猴子最后能得到的桃子数**：`n + (X+4)*(4/5)^n - 4 = n + 4^n - 4`<br>
　　因为老猴子能得到的桃子主要有两个来源：一是每个小猴子都要给一个，有 n 只小猴子，就可以得到 n 个；二是最后剩余的桃子都归老猴子所有，从上面最后一次的结果来看，一共剩余了 `(X+4)*(4/5)^n` 个桃子，但是这里面包括我们最早借给它们的 4 个，实际上剩余的桃子数为 `(X+4)*(4/5)^n - 4` ，所以最后总共能得到的桃子数就是 `n + (X+4)*(4/5)^n - 4` 。<br>

- **【代码】**
```c ++
#include <iostream>
#include <cmath>

using namespace std;

int main() {
	int n = 0;

	while (cin >> n) {
		if (n == 0)
			break;

		long total = pow(5, n) - 4;
		long left = pow(4, n) + n - 4;
		cout << total << " " << left << endl;
	}

	return 0;
}
```
